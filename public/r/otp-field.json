{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "otp-field",
  "type": "registry:ui",
  "dependencies": [
    "react"
  ],
  "registryDependencies": [],
  "files": [
    {
      "path": "src/components/ui/otp-field.tsx",
      "content": "'use client';\n\nimport { TextField } from '@/components/ui/text-field';\nimport React, { ClipboardEvent, KeyboardEvent, useRef, useState } from 'react';\nimport { cn } from '@/lib/theme-utils';\n\nexport interface OTPFieldProps {\n  length?: number;\n  className?: string;\n  placeholder?: string;\n  disabled?: boolean;\n  onChange?: (value: string) => void;\n  autoSubmit?: (value: string) => void;\n  separator?: {\n    character?: string;\n    afterEvery?: number;\n  };\n}\n\nfunction OTPField({\n  length = 6,\n  placeholder,\n  disabled,\n  className,\n  onChange,\n  autoSubmit,\n  separator,\n}: OTPFieldProps) {\n  const [otp, setOtp] = useState<string[]>(new Array(length).fill(''));\n  const inputRefs = useRef<(HTMLInputElement | null)[]>([]);\n\n  const handleChange = (element: HTMLInputElement, index: number) => {\n    const value = element.value;\n    if (isNaN(Number(value))) return;\n\n    const newOtp = [...otp];\n    newOtp[index] = value.substring(value.length - 1);\n    setOtp(newOtp);\n\n    const otpValue = newOtp.join('');\n    onChange?.(otpValue);\n\n    if (otpValue.length === length && autoSubmit) {\n      autoSubmit(otpValue);\n    }\n\n    if (value && index < length - 1) {\n      inputRefs.current[index + 1]?.focus();\n    }\n  };\n\n  const handleKeyDown = (e: KeyboardEvent<HTMLInputElement>, index: number) => {\n    if ((e.key === 'Delete' || e.key === 'Backspace') && (e.ctrlKey || e.metaKey)) {\n      e.preventDefault();\n      const newOtp = new Array(length).fill('');\n      setOtp(newOtp);\n      onChange?.('');\n      inputRefs.current[0]?.focus();\n      return;\n    }\n\n    if (e.key === 'ArrowLeft') {\n      e.preventDefault();\n      if (index > 0) {\n        inputRefs.current[index - 1]?.focus();\n      }\n      return;\n    }\n\n    if (e.key === 'ArrowRight') {\n      e.preventDefault();\n      if (index < length - 1) {\n        inputRefs.current[index + 1]?.focus();\n      }\n      return;\n    }\n\n    if (e.key === 'Home') {\n      e.preventDefault();\n      inputRefs.current[0]?.focus();\n      return;\n    }\n\n    if (e.key === 'End') {\n      e.preventDefault();\n      inputRefs.current[length - 1]?.focus();\n      return;\n    }\n\n    if (e.key === 'Backspace') {\n      if (!otp[index] && index > 0) {\n        const newOtp = [...otp];\n        newOtp[index - 1] = '';\n        setOtp(newOtp);\n        onChange?.(newOtp.join(''));\n        inputRefs.current[index - 1]?.focus();\n      }\n      return;\n    }\n\n    if (e.key === 'Delete') {\n      if (otp[index]) {\n        const newOtp = [...otp];\n        newOtp[index] = '';\n        setOtp(newOtp);\n        onChange?.(newOtp.join(''));\n      } else if (index < length - 1) {\n        const newOtp = [...otp];\n        newOtp[index + 1] = '';\n        setOtp(newOtp);\n        onChange?.(newOtp.join(''));\n      }\n      return;\n    }\n\n    if (e.key === ' ') {\n      e.preventDefault();\n      const nextEmptyIndex = otp.findIndex((digit, i) => i > index && !digit);\n      if (nextEmptyIndex !== -1) {\n        inputRefs.current[nextEmptyIndex]?.focus();\n      } else if (index < length - 1) {\n        inputRefs.current[index + 1]?.focus();\n      }\n      return;\n    }\n  };\n\n  const handlePaste = (e: ClipboardEvent<HTMLInputElement>, startIndex: number) => {\n    e.preventDefault();\n    const pasteData = e.clipboardData.getData('text').replace(/[^0-9]/g, '');\n\n    if (!pasteData) return;\n\n    const newOtp = [...otp];\n    const availableSlots = length - startIndex;\n    const digitsToPaste = pasteData.slice(0, availableSlots);\n\n    for (let i = startIndex; i < Math.min(startIndex + digitsToPaste.length, length); i++) {\n      newOtp[i] = '';\n    }\n\n    for (let i = 0; i < digitsToPaste.length && startIndex + i < length; i++) {\n      newOtp[startIndex + i] = digitsToPaste[i];\n    }\n\n    setOtp(newOtp);\n    const otpValue = newOtp.join('');\n    onChange?.(otpValue);\n\n    if (otpValue.length === length && autoSubmit) {\n      autoSubmit(otpValue);\n    }\n\n    const nextFocusIndex = Math.min(startIndex + digitsToPaste.length, length - 1);\n    setTimeout(() => {\n      inputRefs.current[nextFocusIndex]?.focus();\n    }, 0);\n  };\n\n  return (\n    <div className={cn('flex w-full items-center gap-2', className)}>\n      {otp.map((digit, index) => (\n        <React.Fragment key={index}>\n          <TextField\n            ref={(el) => {\n              inputRefs.current[index] = el as HTMLInputElement;\n            }}\n            type=\"text\"\n            inputMode=\"numeric\"\n            maxLength={1}\n            value={digit}\n            placeholder={placeholder}\n            disabled={disabled}\n            className=\"flex-1 text-xl font-semibold *:text-center has-[input]:text-center\"\n            onChange={(e) => handleChange(e.target, index)}\n            onKeyDown={(e) => handleKeyDown(e, index)}\n            onPaste={(e) => handlePaste(e, index)}\n          />\n          {separator?.afterEvery &&\n            (index + 1) % separator.afterEvery === 0 &&\n            index < length - 1 && (\n              <span className=\"text-muted-foreground text-2xl font-semibold\">\n                {separator.character || '-'}\n              </span>\n            )}\n        </React.Fragment>\n      ))}\n    </div>\n  );\n}\n\nexport { OTPField };\n",
      "type": "registry:ui",
      "target": "components/ui/otp-field.tsx"
    }
  ]
}